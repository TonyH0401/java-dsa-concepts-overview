public class BSTree<E extends Comparable<E>> {
    private Node<E> root;

    public Node<E> getRoot() {
        return this.root;
    }

    public void setRoot(Node<E> root) {
        this.root = root;
    }

    public BSTree() {
        root = null;
    }

    public void insert(E key) {
        root = insert(root, key);
    }

    private Node<E> insert(Node<E> node, E key) {
        if (node == null) {
            return new Node<E>(key); // if the BSTree is empty
        }
        if (key.compareTo(node.getKey()) > 0) {
            node.setRight(insert(node.getRight(), key));
        } else if (key.compareTo(node.getKey()) < 0) {
            node.setLeft(insert(node.getLeft(), key));
        } else {
            return node;
        }

        // update the height of the root
        node.setHeight(1 + (int) Math.max((double) height(node.getLeft()), (double) height(node.getRight())));

        // auto balance at insert
        if (!isImBalance(node)) {
            return node;
        }

        if (node.getLeft() != null && key.compareTo(node.getLeft().getKey()) < 0)
            return rotateRight(node);

        if (node.getRight() != null && key.compareTo(node.getRight().getKey()) > 0)
            return rotateLeft(node);

        if (node.getLeft() != null && key.compareTo(node.getLeft().getKey()) > 0) {
            node.setLeft(rotateLeft(node.getLeft()));
            return rotateRight(node);
        }
        if (node.getRight() != null && key.compareTo(node.getRight().getKey()) < 0) {
            node.setRight(rotateRight(node.getRight()));
            return rotateLeft(node);
        }

        return node;
    }

    // print
    public void print() {
        print(root, 0);
    }

    private void print(Node<E> node, int level) {
        if (node == null) {
            return;
        }
        // print(node.getLeft(), level + 1);
        print(node.getRight(), level + 1);

        for (int i = 1; i <= level; i++) {
            System.out.print("\t");
        }
        System.out.println(node.getKey());

        print(node.getLeft(), level + 1);
        // print(node.getRight(), level + 1);
    }

    // post order
    public void print_post_order() {
        print_post_order(root, 0);
    }

    public void print_post_order(Node<E> node, int level) {
        if (node == null) {
            return;
        }
        print_post_order(node.getLeft(), level + 1);
        print_post_order(node.getRight(), level + 1);
        System.out.println(node.getKey());
    }

    // pre order
    public void print_pre_order() {
        print_pre_order(root, 0);
    }

    public void print_pre_order(Node<E> node, int level) {
        if (node == null) {
            return;
        }
        System.out.println(node.getKey());
        print_pre_order(node.getLeft(), level + 1);
        print_pre_order(node.getRight(), level + 1);
    }

    // contains and search
    public boolean contains(E key) {
        if (search(root, key) == null)
            return false;
        return true;
    }

    private Node<E> search(Node<E> node, E key) {
        if (node == null)
            return null;
        if (key.compareTo(node.getKey()) < 0) {
            return search(node.getLeft(), key);
        } else if (key.compareTo(node.getKey()) > 0) {
            return search(node.getRight(), key);
        } else {
            return node;
        }
    }

    // max
    public E max() {
        return max(root).getKey();
    }

    private Node<E> max(Node<E> node) {
        if (node.getRight() == null)
            return node;
        else
            return max(node.getRight());
    }

    // min
    public E min() {
        return min(root).getKey();
    }

    private Node<E> min(Node<E> node) {
        if (node.getLeft() == null)
            return node;
        else
            return min(node.getLeft());
    }

    // delete max
    public void deleteMax() {
        root = deleteMax(root);
    }

    private Node<E> deleteMax(Node<E> node) {
        if (node.getRight() == null)
            return node.getLeft();

        node.setRight(deleteMax(node.getRight()));
        return node;
    }

    // delete min
    public void deleteMin() {
        root = deleteMin(root);
    }

    private Node<E> deleteMin(Node<E> node) {
        if (node.getLeft() == null)
            return node.getRight();

        node.setLeft(deleteMin(node.getLeft()));
        return node;
    }

    // delete
    public void delete(E key) {
        if (contains(key) == false) {
            System.out.println("No key exist in this tree");
            return;
        }
        // update the root
        root = delete(root, key);
    }

    private Node<E> delete(Node<E> node, E key) {
        if (node == null)
            return null;
        if (key.compareTo(node.getKey()) < 0) {
            node.setLeft(delete(node.getLeft(), key));
        } else if (key.compareTo(node.getKey()) > 0) {
            node.setRight(delete(node.getRight(), key));
        } else {
            // node with one child or a leaf
            if (node.getRight() == null)
                return node.getLeft();
            if (node.getLeft() == null)
                return node.getRight();

            // node with two children
            Node<E> t = node;
            node = min(t.getRight());
            node.setRight(deleteMin(t.getRight()));
            node.setLeft(t.getLeft());
        }

        // update the height
        node.setHeight(1 + (int) Math.max((double) height(node.getLeft()), (double) height(node.getRight())));

        if (!isImBalance(node)) {
            return node;
        }
        

        int balance = getBalance(node);
        // If this node becomes unbalanced, then there are 4 cases
        // Left Left Case
        if (balance > 1 && getBalance(node.getLeft()) >= 0)
            return rotateRight(node);

        // Left Right Case
        if (balance > 1 && getBalance(node.getLeft()) < 0) {
            node.setLeft(rotateLeft(node.getLeft()));
            return rotateRight(node);
        }

        // // Right Right Case
        if (balance < -1 && getBalance(node.getRight()) <= 0)
            return rotateLeft(node);

        // // Right Left Case
        if (balance < -1 && getBalance(node.getLeft()) > 0) {
            node.setRight(rotateRight(node.getRight()));
            return rotateLeft(node);
        }

        return node;
    }

    // get height
    public int getHeight() {
        return getHeight(root);
    }

    private int getHeight(Node<E> node) {
        if (node == null)
            return 0;

        int leftHeight = getHeight(node.getLeft());
        int rightHeight = getHeight(node.getRight());

        return (1 + Math.max(leftHeight, rightHeight));
    }

    // =====================================================================================================================

    private Node<E> rotateLeft(Node<E> x) {
        Node<E> y = x.getRight();
        x.setRight(y.getLeft());
        y.setLeft(x);
        x.setHeight(1 + Math.max(height(x.getLeft()), height(x.getRight())));
        y.setHeight(1 + Math.max(height(y.getLeft()), height(y.getRight())));

        return y;
    }

    private Node<E> rotateRight(Node<E> x) {
        Node<E> y = x.getLeft();
        x.setLeft(y.getRight());
        y.setRight(x);
        x.setHeight(1 + Math.max(height(x.getLeft()), height(x.getRight())));
        y.setHeight(1 + Math.max(height(y.getLeft()), height(y.getRight())));

        return y;
    }

    private boolean isImBalance(Node<E> node) {
        int factor = height(node.getLeft()) - height(node.getRight());
        if (factor > 1 || factor < -1)
            return true;
        return false;
    }

    private int getBalance(Node<E> node) {
        if (node == null)
            return 0;
        return height(node.getLeft()) - height(node.getRight());
    }

}
